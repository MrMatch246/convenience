from pentesting.utils import *

# Phase: Recon
# Stage 0: Setup
# We will then check if there is an arg provided for the project folder (relative or absolute path).
# --project <path>
# now for each completed Stage we will create a file called .stage<x> in project_folder/recon.
# in the following Stages we will always first check if the file exists and if it does we will skip that stage,
# unless there is a flag to force the stage to run again. --run-stage x
# This will also re-run all following stages.
# First we will try to load the self.project_data from the <project_folder>/<project_folder>.json file,
# then we will load the self.phase_config from self.project_data["config"]["phases"]["recon"].
# here we will also load the self.stages from self.project_data["config"]["phases"]["recon"]["stages"],
# and self.project_general config from self.project_data["config"]["general"].
# and finally we will load the self.phase_general config from self.project_data["config"]["phases"]["recon"]["general"].
# for each config we will default to an empty dict if the key is not present.
# it might be that even the self.project_data["config"] is not present,
# in that case we will create an empty dict for self.project_data["config"] and so on.
#
#
# Stage 1: Mass Host Discovery
# In this stage we will use masscan to discover hosts in the target network.
# In all the following a target describes a single line in the <project_folder>/scope/targets.txt file.
# The targets can be a single IP, a range of IPs or a CIDR notation or a domain name.
# To discover live hosts fast we will use masscan:
# sudo masscan <project_folder>/scope/targets.txt -p80,443 --ping --retries 1 --wait 10 --rate=<rate> --open [2>/dev/null] | awk '{print $6}'
# and capture the output and write into <project_folder>/recon/stage_1/masscan_hosts.txt
#
#
# Stage 2: Quick Leftover Host Discovery
# If there is already a file called <project_folder>/recon/stage_2/found_quick_leftover_hosts.gnmap we will skip Stage 2.
# The first part of this stage will be to discover hosts that were not found in the previous stage.
# For this we will compose a list of all IPs in the target networks, minus the ones that were found in the previous stage.
# These are then split into chunks of <chunk_size> IPs, where <chunk_size> is defined in the self.stages["stage_2"]["host_discovery"]["chunk-size"] config.
# for example if the target is a.b.c.0/24 and <chunk_size> is 50,
# we will create chunks like this:
# a.b.c.0-a.b.c.49, a.b.c.50-a.b.c.99... (.255 is not included)
#
# We will then, for each chunk of each target, create a file called <project_folder>/recon/stage_2/chunks/leftover_hosts_a.b.c.<start>-a.b.c.<end>.txt
# if a target is only a single IP, we will create a file called <project_folder>/recon/stage_2/chunks/leftover_hosts_<ip>.txt
# Now for all chunks that havent been processed yet, which means the file <project_folder>/recon/stage_2/processed_chunks/found_quick_leftover_hosts_<chunk>.gnmap does not exist,
# we will spawn a python process (NmapRunner - LeftoverFinder) that goes through the list of all chunks and runs nmap on each one using the leftover_hosts_<chunk>.txt file as input.
# As we dont need any direct output from this process we will run it in the background and detach it.
# The nmap command will be:
# nmap -sn -n -Pn --top-ports 100 -iL <project_folder>/recon/stage_2/chunks/leftover_hosts_<chunk>.txt -oG <project_folder>/recon/stage_2/processed_chunks/found_quick_leftover_hosts_<chunk>.gnmap
# After all chunks have been processed we will merge all found_leftover_hosts_<subnet>.gnmap files into one file called <project_folder>/recon/stage_2/found_quick_leftover_hosts.txt
# containing only the IPs of the hosts that were found in the previous stage.
# Now once we have the leftover hosts we will use them, too, as input for Stage 3.
# This includes using a file watcher to monitor the <project_folder>/recon/stage_2/found_quick_leftover_hosts.txt file for creation.
#
# Stage 3: Deep Scanning
# This stage starts immediately after LeftoverFinder has been started and detached.
# Here we will spawn a named Tmux session (or attach to it if it already exists) called autorecon-mass-scan.
# using this session we will run the AutoReconRunner (DeepScanner) to scan the hosts that were found in Stage 1.
# while being able to monitor the progress in real-time and meanwhile also being able to monitor the leftover hosts discovery in Stage 2.
# The AutoReconRunner (DeepScanner) Python script will be given a file containing the live hosts to scan,
# which is --hosts <project_folder>/recon/stage_1/masscan_hosts.txt,
# a --config as defined in the self.stages["stage_2"]["autorecon-scan"] (optional),
# the original --targets <project_folder>/scope/targets.txt file,
# and optionally a config for autorecon defined in the self.stages["stage_2"]["autorecon-scan"]["autorecon"] config.
# and via --output-dir <project_folder>/recon/hosts as output directory.
# After the AutoReconRunner (DeepMassScanner) has been started in the autorecon-mass-scan tmux session, we will detach from it,
# and then we will monitor the <project_folder>/recon/stage_2/ folder for the creation of the file <project_folder>/recon/stage_2/found_quick_leftover_hosts.txt.
# Once this file is created, we will spawn another tmux session (or attach to it if it already exists) called autorecon-leftover-scan.
# And again we will run the AutoReconRunner (DeepLeftoverScanner) to scan the leftover hosts that were found in Stage 2.
# this time we will use the file <project_folder>/recon/stage_2/found_quick_leftover_hosts.txt as --hosts input.
#
#



import argparse
import json
import os
import subprocess
import sys
import time
from pathlib import Path
from pentesting.recon.NmapRunner import *
from pentesting.recon.AutoReconRunner import *

class Recon:
    def __init__(self,project_folder, run_stage=1):
        self.project_folder = Path(project_folder).resolve()
        self.run_stage = run_stage
        self.recon_folder = self.project_folder / "recon"
        self.stages_folder = self.recon_folder
        self.scope_file = self.project_folder / "scope" / "targets.txt"

        # Ensure recon directory exists
        self.recon_folder.mkdir(parents=True, exist_ok=True)

        # Load project data and config
        self.project_data = self.load_project_data()
        self.phase_config = self.project_data.get("config", {}).get("phases", {}).get("recon", {})
        self.stages = self.phase_config.get("stages", {})
        self.project_general = self.project_data.get("config", {}).get("general", {})
        self.phase_general = self.phase_config.get("general", {})


    def load_project_data(self):
        project_json = self.project_folder / f"{self.project_folder.name}.json"
        if project_json.exists():
            with open(project_json, "r") as f:
                return json.load(f)
        return {}

    def stage_marker(self, stage):
        return self.recon_folder / f".stage{stage}"

    def run(self):
        # Stage 0 Setup is implicit here (loading configs)
        if self.should_run_stage(1):
            self.run_stage_1()
        if self.should_run_stage(2):
            self.run_stage_2()
        if self.should_run_stage(3):
            self.run_stage_3()

    def should_run_stage(self, stage):
        marker = self.stage_marker(stage)
        if self.run_stage and stage >= self.run_stage:
            return True
        return not marker.exists()

    def mark_stage_complete(self, stage):
        self.stage_marker(stage).touch()

    # Stage 1: Mass Host Discovery
    def run_stage_1(self):
        print("[*] Running Stage 1: Mass Host Discovery")
        stage_dir = self.recon_folder / "stage_1"
        stage_dir.mkdir(parents=True, exist_ok=True)
        output_file = stage_dir / "masscan_hosts.txt"

        rate = self.stages.get("stage_1", {}).get("masscan", {}).get("rate", "10000")
        cmd = f"sudo masscan -iL {self.scope_file} -p80,443 --ping --retries 1 --wait 10 --rate {rate} --open 2>/dev/null |"+" awk '{print $6}' > "+f"{output_file}"
        print(cmd)
        subprocess.run(cmd, shell=True, check=True)
        self.mark_stage_complete(1)

    # Stage 2: Quick Leftover Host Discovery
    def run_stage_2(self):
        print("[*] Running Stage 2: Quick Leftover Host Discovery")
        stage_dir = self.recon_folder / "stage_2"
        chunks_dir = stage_dir / "chunks"
        processed_dir = stage_dir / "processed_chunks"
        stage_dir.mkdir(parents=True, exist_ok=True)
        chunks_dir.mkdir(parents=True, exist_ok=True)
        processed_dir.mkdir(parents=True, exist_ok=True)

        leftover_file = stage_dir / "found_quick_leftover_hosts.txt"
        if leftover_file.exists():
            print("[*] Stage 2 already completed. Skipping.")
            return

        chunk_size = self.stages.get("stage_2", {}).get("host_discovery", {}).get("chunk-size", 50)
        # Generate chunks (using utility functions assumed available from toolboxes.pentesting.utils)
        live_hosts = load_lines(self.recon_folder / "stage_1/masscan_hosts.txt")
        targets = load_lines(self.scope_file)
        chunks = generate_leftover_chunks(targets, live_hosts, chunk_size, chunks_dir)

        print(f"[*] Spawning NmapRunner for {len(chunks)} chunks in background...")
        subprocess.Popen([sys.executable, "NmapRunner.py", "--project", str(self.project_folder)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)

        self.mark_stage_complete(2)

    # Stage 3: Deep Scanning
    def run_stage_3(self):
        print("[*] Running Stage 3: Deep Scanning")

        # Start AutoRecon for Stage 1 hosts
        tmux_session = "autorecon-mass-scan"
        hosts_file = self.recon_folder / "stage_1/masscan_hosts.txt"
        self.start_tmux_session(tmux_session, f"python3 AutoReconRunner.py --project {self.project_folder} --hosts {hosts_file}")

        # Watch for leftover hosts and launch second scan
        leftover_file = self.recon_folder / "stage_2/found_quick_leftover_hosts.txt"
        print(f"[*] Monitoring {leftover_file} for leftover host scan...")
        while not leftover_file.exists():
            time.sleep(10)

        tmux_session_leftover = "autorecon-leftover-scan"
        self.start_tmux_session(tmux_session_leftover, f"python3 AutoReconRunner.py --project {self.project_folder} --hosts {leftover_file}")

        self.mark_stage_complete(3)

    def start_tmux_session(self, name, cmd):
        subprocess.run(f"tmux new-session -d -s {name} '{cmd}'", shell=True)
        print(f"[*] Started tmux session: {name}")

if __name__ == "__main__":
    Recon().run()
