#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import xml.etree.ElementTree as ET
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn

console = Console()

def parse_args():
    parser = argparse.ArgumentParser(description="SNMP Dumper: Parse Nmap XML, extract SNMP creds, and run snmpbulkwalk.")
    parser.add_argument("--input", required=True, help="Input: directory (recursive) or single XML file")
    parser.add_argument("--output", required=True, help="Output directory for SNMP dumps")
    parser.add_argument("--prefix", default="", help="Prefix for output files")
    parser.add_argument("--quiet", action="store_true", help="Suppress prints")
    return parser.parse_args()

def log(msg, style="cyan", quiet=False):
    if not quiet:
        console.print(f"[{style}]{msg}[/{style}]")

def find_xml_files(input_path):
    p = Path(input_path)
    if p.is_file() and p.suffix == ".xml":
        return [p]
    elif p.is_dir():
        return list(p.rglob("*.xml"))
    else:
        raise ValueError(f"Invalid input path: {input_path}")

def extract_snmp_hosts(xml_files):
    """Extract hosts with SNMP (open or detected by scripts) and credentials from snmp-brute."""
    snmp_hosts = {}  # {host_ip: [community_strings]}
    for xml_file in xml_files:
        tree = ET.parse(xml_file)
        root = tree.getroot()

        for host in root.findall("host"):
            addr_elem = host.find("address[@addrtype='ipv4']")
            if addr_elem is None:
                continue
            ip = addr_elem.get("addr")

            # Find any UDP 161 port entry (open or closed, but still has scripts)
            port = host.find("ports/port[@protocol='udp'][@portid='161']")
            if port is None:
                continue

            creds = []

            # Parse snmp-brute script block
            for script in port.findall("script[@id='snmp-brute']"):
                # Preferred: Use <elem key="password"> tags instead of raw output parsing
                for elem in script.findall("table"):
                    pwd = elem.find("elem[@key='password']")
                    state = elem.find("elem[@key='state']")
                    if pwd is not None and state is not None and "valid" in state.text.lower():
                        creds.append(pwd.text)

                # Fallback: Check output attribute for simple parsing
                output = script.get("output", "")
                if "Valid" in output and "-" in output:
                    parts = output.split("-")[0].strip().split()
                    if parts:
                        creds.append(parts[0])  # First token (e.g., "public")

            if creds:
                snmp_hosts[ip] = list(set(creds))  # Deduplicate

    return snmp_hosts


def run_snmpbulkwalk(host, communities, output_dir, prefix, quiet=False):
    """Run snmpbulkwalk for each valid community string."""
    outfile = Path(output_dir) / f"{prefix + '_' if prefix else ''}{host}_snmp_dump.txt"

    if outfile.exists():
        log(f"[SKIP] {host} (already processed)", style="yellow", quiet=quiet)
        return

    tmpfile = outfile.with_suffix(".tmp")

    try:
        with tmpfile.open("w") as out:
            for comm in communities:
                log(f"[SNMP] {host} using community '{comm}'", style="blue", quiet=quiet)
                cmd = ["snmpbulkwalk", "-On", "-v2c", "-c", comm, host, "1"]
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                    if result.returncode == 0 and result.stdout.strip():
                        out.write(f"### Community: {comm}\n")
                        out.write(result.stdout)
                        out.write("\n\n")
                    else:
                        out.write(f"### Community: {comm} (FAILED)\n{result.stderr}\n\n")
                except subprocess.TimeoutExpired:
                    out.write(f"### Community: {comm} (TIMEOUT)\n\n")

        tmpfile.rename(outfile)
        log(f"[DONE] Dump saved: {outfile}", style="green", quiet=quiet)

    except KeyboardInterrupt:
        log(f"[INTERRUPT] Removing partial file: {tmpfile}", style="red", quiet=quiet)
        if tmpfile.exists():
            tmpfile.unlink()
        raise

def main():
    args = parse_args()
    os.makedirs(args.output, exist_ok=True)

    xml_files = find_xml_files(args.input)
    log(f"[+] Found {len(xml_files)} XML file(s)", style="cyan", quiet=args.quiet)

    snmp_hosts = extract_snmp_hosts(xml_files)
    log(f"[+] Found {len(snmp_hosts)} hosts with SNMP and valid creds", style="cyan", quiet=args.quiet)

    if args.quiet:
        for host, creds in snmp_hosts.items():
            run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
    else:
        with Progress(SpinnerColumn(), TextColumn("[cyan]{task.description}"), BarColumn(), TextColumn("{task.completed}/{task.total}"), console=console) as progress:
            task = progress.add_task("[white]Processing hosts...", total=len(snmp_hosts))
            for host, creds in snmp_hosts.items():
                run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
                progress.advance(task)

if __name__ == "__main__":
    main()
