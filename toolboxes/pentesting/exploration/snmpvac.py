#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import xml.etree.ElementTree as ET
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn

console = Console()

def parse_args():
    parser = argparse.ArgumentParser(description="SNMP Dumper: Parse Nmap XML, extract SNMP creds, and run snmpbulkwalk.")
    parser.add_argument("--input", required=True, help="Input: directory (recursive) or single XML file")
    parser.add_argument("--output", required=True, help="Output directory for SNMP dumps")
    parser.add_argument("--prefix", default="", help="Prefix for output files")
    parser.add_argument("--quiet", action="store_true", help="Suppress prints")
    return parser.parse_args()

def log(msg, style="cyan", quiet=False):
    if not quiet:
        console.print(f"[{style}]{msg}[/{style}]")

def find_xml_files(input_path):
    p = Path(input_path)
    if p.is_file() and p.suffix == ".xml":
        return [p]
    elif p.is_dir():
        return list(p.rglob("*.xml"))
    else:
        raise ValueError(f"Invalid input path: {input_path}")

def extract_snmp_hosts(xml_files):
    """Extract hosts with SNMP (open or detected by scripts) and credentials from snmp-brute."""
    snmp_hosts = {}  # {host_ip: [community_strings]}
    for xml_file in xml_files:
        tree = ET.parse(xml_file)
        root = tree.getroot()

        for host in root.findall("host"):
            addr_elem = host.find("address[@addrtype='ipv4']")
            if addr_elem is None:
                continue
            ip = addr_elem.get("addr")

            # Find any UDP 161 port entry (open or closed, but still has scripts)
            port = host.find("ports/port[@protocol='udp'][@portid='161']")
            if port is None:
                continue

            creds = []

            # Parse snmp-brute script block
            for script in port.findall("script[@id='snmp-brute']"):
                # Preferred: Use <elem key="password"> tags instead of raw output parsing
                for elem in script.findall("table"):
                    pwd = elem.find("elem[@key='password']")
                    state = elem.find("elem[@key='state']")
                    if pwd is not None and state is not None and "valid" in state.text.lower():
                        creds.append(pwd.text)

                # Fallback: Check output attribute for simple parsing
                output = script.get("output", "")
                if "Valid" in output and "-" in output:
                    parts = output.split("-")[0].strip().split()
                    if parts:
                        creds.append(parts[0])  # First token (e.g., "public")

            if creds:
                snmp_hosts[ip] = list(set(creds))  # Deduplicate

    return snmp_hosts


def run_snmpbulkwalk(host, communities, output_dir, prefix, quiet=False):
    """Run snmpbulkwalk for each valid community string and deduplicate OIDs."""
    outfile = Path(output_dir) / f"{prefix + '_' if prefix else ''}{host}_snmp_dump.txt"

    if outfile.exists():
        log(f"[SKIP] {host} (already processed)", style="yellow", quiet=quiet)
        return

    tmpfile = outfile.with_suffix(".tmp")

    seen_oids = {}  # {oid: "value line"}

    try:
        for comm in communities:
            log(f"[SNMP] {host} using community '{comm}'", style="blue", quiet=quiet)
            cmd = ["snmpbulkwalk", "-On", "-v2c", "-c", comm, host, "1"]

            try:
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                if result.returncode == 0 and result.stdout.strip():
                    for line in result.stdout.splitlines():
                        if line.strip() == "" or "Timeout" in line:
                            continue
                        # Parse OID (everything before first " = ")
                        if " = " in line:
                            oid = line.split(" = ", 1)[0].strip()
                            seen_oids[oid] = line
                else:
                    log(f"[FAIL] Community '{comm}' on {host} (no response)", style="red", quiet=quiet)
            except subprocess.TimeoutExpired:
                log(f"[TIMEOUT] {host} with community '{comm}'", style="red", quiet=quiet)

        # Write final deduplicated dump
        with tmpfile.open("w") as out:
            out.write(f"# SNMP dump for {host}\n")
            out.write(f"# Communities tried: {', '.join(communities)}\n\n")
            for oid_line in sorted(seen_oids.values()):  # Sort OIDs for consistency
                out.write(oid_line + "\n")

        tmpfile.rename(outfile)
        log(f"[DONE] Dump saved: {outfile}", style="green", quiet=quiet)

    except KeyboardInterrupt:
        log(f"[INTERRUPT] Removing partial file: {tmpfile}", style="red", quiet=quiet)
        if tmpfile.exists():
            tmpfile.unlink()
        raise


def main():
    args = parse_args()
    os.makedirs(args.output, exist_ok=True)

    xml_files = find_xml_files(args.input)
    log(f"[+] Found {len(xml_files)} XML file(s)", style="cyan", quiet=args.quiet)

    snmp_hosts = extract_snmp_hosts(xml_files)
    log(f"[+] Found {len(snmp_hosts)} hosts with SNMP and valid creds", style="cyan", quiet=args.quiet)

    if args.quiet:
        for host, creds in snmp_hosts.items():
            run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
    else:
        with Progress(SpinnerColumn(), TextColumn("[cyan]{task.description}"), BarColumn(), TextColumn("{task.completed}/{task.total}"), console=console) as progress:
            task = progress.add_task("[white]Processing hosts...", total=len(snmp_hosts))
            for host, creds in snmp_hosts.items():
                run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
                progress.advance(task)

if __name__ == "__main__":
    main()
