#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import xml.etree.ElementTree as ET
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn

console = Console()

# ðŸ”‘ Ordered SNMP OIDs (broad â†’ narrow fallback)
OID_FALLBACKS = [
    "1",                        # Full walk
    "1.3.6.1.2.1.1",            # System MIB
    "1.3.6.1.2.1.2",            # Interfaces
    "1.3.6.1.2.1.4",            # IP layer info (ARP/routing)
    "1.3.6.1.2.1.25",           # Host resources (procs, storage, software)
    "1.3.6.1.2.1.6",            # TCP connections
    "1.3.6.1.2.1.7",            # UDP listeners
    "1.3.6.1.4.1.2021",         # Net-SNMP (Linux)
    "1.3.6.1.4.1.77",           # Windows users (LANMAN)
    "1.3.6.1.4.1.311",          # Microsoft extensions
    "1.3.6.1.4.1.9",            # Cisco-specific
    "1.3.6.1.2.1.43",           # Printer-MIB
    "1.3.6.1.4.1",              # Enterprise/vendor tree
]

def parse_args():
    parser = argparse.ArgumentParser(description="SNMP Dumper: Parse Nmap XML, extract SNMP creds, and run snmpbulkwalk.")
    parser.add_argument("--input", required=True, help="Input: directory (recursive) or single XML file")
    parser.add_argument("--output", required=True, help="Output directory for SNMP dumps")
    parser.add_argument("--prefix", default="", help="Prefix for output files")
    parser.add_argument("--quiet", action="store_true", help="Suppress prints")
    return parser.parse_args()

def log(msg, style="cyan", quiet=False):
    if not quiet:
        console.print(f"[{style}]{msg}[/{style}]")

def find_xml_files(input_path):
    p = Path(input_path)
    if p.is_file() and p.suffix == ".xml":
        return [p]
    elif p.is_dir():
        return list(p.rglob("*.xml"))
    else:
        raise ValueError(f"Invalid input path: {input_path}")

def extract_snmp_hosts(xml_files):
    snmp_hosts = {}
    for xml_file in xml_files:
        tree = ET.parse(xml_file)
        root = tree.getroot()

        for host in root.findall("host"):
            addr_elem = host.find("address[@addrtype='ipv4']")
            if addr_elem is None:
                continue
            ip = addr_elem.get("addr")

            port = host.find("ports/port[@protocol='udp'][@portid='161']")
            if port is None:
                continue

            creds = []
            for script in port.findall("script[@id='snmp-brute']"):
                for elem in script.findall("table"):
                    pwd = elem.find("elem[@key='password']")
                    state = elem.find("elem[@key='state']")
                    if pwd is not None and state is not None and "valid" in state.text.lower():
                        creds.append(pwd.text)

                output = script.get("output", "")
                if "Valid" in output and "-" in output:
                    parts = output.split("-")[0].strip().split()
                    if parts:
                        creds.append(parts[0])

            if creds:
                snmp_hosts[ip] = list(set(creds))
    return snmp_hosts

def run_snmpbulkwalk(host, communities, output_dir, prefix, quiet=False):
    outfile = Path(output_dir) / f"{prefix + '_' if prefix else ''}{host}_dump.snmp"

    if outfile.exists():
        log(f"[SKIP] {host} (already processed)", style="yellow", quiet=quiet)
        return

    tmpfile = outfile.with_suffix(".tmp")
    seen_oids = {}
    timeout = "5"

    def parse_snmp_output(community, output):
        for line in output.splitlines():
            if not line.strip() or "Timeout" in line:
                continue
            if " = " in line:
                oid, value = line.split(" = ", 1)
                seen_oids.setdefault(oid.strip(), []).append((community, value.strip()))

    def run_snmp_command(cmd, desc, community):
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=190)
            if result.returncode == 0 and result.stdout.strip():
                parse_snmp_output(community, result.stdout)
                log(f"[SNMP] {host} ({desc})", style="blue", quiet=quiet)
                return True
            elif result.returncode == 2:  # Partial success
                log(f"[PARTIAL] {host} ({desc})", style="yellow", quiet=quiet)
                parse_snmp_output(community, result.stdout)
                return False
            else:
                return False
        except subprocess.TimeoutExpired:
            log(f"[TIMEOUT] {desc}", style="red", quiet=quiet)
            return False

    try:
        for comm in communities:
            log(f"[+] Testing community '{comm}' on {host}", style="cyan", quiet=quiet)

            # Iterate over fallback OIDs
            for oid in OID_FALLBACKS:
                desc = f"walk OID {oid} (community '{comm}')"

                # Try bulkwalk (fastest)
                if run_snmp_command(
                    ["snmpbulkwalk", "-On", "-t", timeout, "-r1", "-v2c", "-c", comm, host, oid], desc, comm
                ):
                    continue  # move to next OID if success

                # Retry with reduced bulk size
                run_snmp_command(
                    ["snmpbulkwalk", "-On", "-t", timeout, "-r1", "-Cr10", "-v2c", "-c", comm, host, oid], desc + " (-Cr10)", comm
                )

                # Fallback to normal walk (v2c then v1)
                run_snmp_command(
                    ["snmpwalk", "-On", "-Cc", "-t", timeout, "-r1", "-v2c", "-c", comm, host, oid], desc + " (v2c walk)", comm
                )
                run_snmp_command(
                    ["snmpwalk", "-On", "-Cc", "-t", timeout, "-r1", "-v1", "-c", comm, host, oid], desc + " (v1 walk)", comm
                )

        if not seen_oids:
            log(f"[EMPTY] No SNMP data found for {host}", style="yellow", quiet=quiet)
            return

        with tmpfile.open("w") as out:
            out.write(f"# SNMP dump for {host}\n")
            out.write(f"# Communities tried: {', '.join(communities)}\n\n")
            for oid in sorted(seen_oids):
                vals = seen_oids[oid]
                unique_vals = {v for _, v in vals}
                if len(unique_vals) == 1:
                    out.write(f"{oid} = {vals[0][1]}  # from {vals[0][0]}\n")
                else:
                    for comm, val in vals:
                        out.write(f"{oid} = {val}  # from {comm}\n")
        tmpfile.rename(outfile)
        log(f"[DONE] Dump saved: {outfile}", style="green", quiet=quiet)

    except KeyboardInterrupt:
        log(f"[INTERRUPT] Removing partial file: {tmpfile}", style="red", quiet=quiet)
        if tmpfile.exists():
            tmpfile.unlink()
        raise

def main():
    args = parse_args()
    os.makedirs(args.output, exist_ok=True)

    xml_files = find_xml_files(args.input)
    log(f"[+] Found {len(xml_files)} XML file(s)", style="cyan", quiet=args.quiet)

    snmp_hosts = extract_snmp_hosts(xml_files)
    log(f"[+] Found {len(snmp_hosts)} hosts with SNMP and valid creds", style="cyan", quiet=args.quiet)

    with open(Path(args.output) / "snmp_hosts_and_creds.json", "w") as f:
        f.write(snmp_hosts.__repr__())

    if args.quiet:
        for host, creds in snmp_hosts.items():
            run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
    else:
        with Progress(SpinnerColumn(), TextColumn("[cyan]{task.description}"), BarColumn(), TextColumn("{task.completed}/{task.total}"), console=console) as progress:
            task = progress.add_task("[white]Processing hosts...", total=len(snmp_hosts))
            for host, creds in snmp_hosts.items():
                run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=False)
                progress.advance(task)

if __name__ == "__main__":
    main()
