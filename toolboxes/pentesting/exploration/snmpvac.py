#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import xml.etree.ElementTree as ET
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn

console = Console()

def parse_args():
    parser = argparse.ArgumentParser(description="SNMP Dumper: Parse Nmap XML, extract SNMP creds, and run snmpbulkwalk.")
    parser.add_argument("--input", required=True, help="Input: directory (recursive) or single XML file")
    parser.add_argument("--output", required=True, help="Output directory for SNMP dumps")
    parser.add_argument("--prefix", default="", help="Prefix for output files")
    parser.add_argument("--quiet", action="store_true", help="Suppress prints")
    return parser.parse_args()

def log(msg, style="cyan", quiet=False):
    if not quiet:
        console.print(f"[{style}]{msg}[/{style}]")

def find_xml_files(input_path):
    p = Path(input_path)
    if p.is_file() and p.suffix == ".xml":
        return [p]
    elif p.is_dir():
        return list(p.rglob("*.xml"))
    else:
        raise ValueError(f"Invalid input path: {input_path}")

def extract_snmp_hosts(xml_files):
    """Extract hosts with SNMP (open or detected by scripts) and credentials from snmp-brute."""
    snmp_hosts = {}  # {host_ip: [community_strings]}
    for xml_file in xml_files:
        tree = ET.parse(xml_file)
        root = tree.getroot()

        for host in root.findall("host"):
            addr_elem = host.find("address[@addrtype='ipv4']")
            if addr_elem is None:
                continue
            ip = addr_elem.get("addr")

            # Find any UDP 161 port entry (open or closed, but still has scripts)
            port = host.find("ports/port[@protocol='udp'][@portid='161']")
            if port is None:
                continue

            creds = []

            # Parse snmp-brute script block
            for script in port.findall("script[@id='snmp-brute']"):
                # Preferred: Use <elem key="password"> tags instead of raw output parsing
                for elem in script.findall("table"):
                    pwd = elem.find("elem[@key='password']")
                    state = elem.find("elem[@key='state']")
                    if pwd is not None and state is not None and "valid" in state.text.lower():
                        creds.append(pwd.text)

                # Fallback: Check output attribute for simple parsing
                output = script.get("output", "")
                if "Valid" in output and "-" in output:
                    parts = output.split("-")[0].strip().split()
                    if parts:
                        creds.append(parts[0])  # First token (e.g., "public")

            if creds:
                snmp_hosts[ip] = list(set(creds))  # Deduplicate

    return snmp_hosts


def run_snmpbulkwalk(host, communities, output_dir, prefix, quiet=False):
    """Run snmpbulkwalk/snmpwalk for each valid community string and deduplicate OIDs with conflict logging."""
    outfile = Path(output_dir) / f"{prefix + '_' if prefix else ''}{host}_dump.snmp"

    if outfile.exists():
        log(f"[SKIP] {host} (already processed)", style="yellow", quiet=quiet)
        return

    tmpfile = outfile.with_suffix(".tmp")
    seen_oids = {}  # {oid: [(community, value_line), ...]}
    timeout = "5"

    def parse_snmp_output(community, output):
        for line in output.splitlines():
            if not line.strip() or "Timeout" in line:
                continue
            if " = " in line:
                oid, value = line.split(" = ", 1)
                oid, value = oid.strip(), value.strip()
                seen_oids.setdefault(oid, []).append((community, value))

    def run_snmp_command(cmd, desc, community):
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=190)
            if result.returncode == 0 and result.stdout.strip():
                parse_snmp_output(community, result.stdout)
                log(f"[SNMP] {host} ({desc})", style="blue", quiet=quiet)
                return True
            elif result.returncode == 2:
                log(f"[Error in Packet] {result.stderr.strip()}", style="yellow", quiet=quiet)
                parse_snmp_output(community, result.stdout)
                return False
            else:
                log(f"[FAIL] {host} {desc} returned no data but return code {result.returncode}", style="red", quiet=quiet)
                log(f"[REASON] {result.stderr.strip()}", style="yellow", quiet=quiet)
                return False
        except subprocess.TimeoutExpired:
            log(f"[TIMEOUT] {desc}", style="red", quiet=quiet)
            return False

    try:
        for comm in communities:
            # SNMPv2c bulk, v2c walk, v1 walk, then high-value MIBs
            any_successful = False
            succeed = run_snmp_command(["snmpbulkwalk", "-On", "-t", timeout, "-r1", "-v2c","-Cr10", "-c", comm, host, "1"],
                             f"v2c bulk (community '{comm}')", comm)
            if succeed:
                any_successful = True
            if not succeed:
                succeed = run_snmp_command(["snmpwalk", "-On", "-Cc", "-t", timeout, "-r1", "-v2c", "-c", comm, host, "1"],
                             f"v2c walk (community '{comm}')", comm)
                if succeed:
                    any_successful = True

            succeed = run_snmp_command(["snmpwalk", "-On", "-Cc", "-t", timeout, "-r1", "-v1", "-c", comm, host, "1"],
                             f"v1 walk (community '{comm}')", comm)
            if succeed:
                any_successful = True

        # âœ… Write final dump with conflict handling
        with tmpfile.open("w") as out:
            out.write(f"# SNMP dump for {host}\n")
            out.write(f"# Communities tried: {', '.join(communities)}\n\n")

            for oid in sorted(seen_oids.keys()):
                values = seen_oids[oid]
                unique_values = {val for _, val in values}

                if len(unique_values) == 1:
                    # Single consistent value
                    comm = values[0][0]
                    out.write(f"{oid} = {values[0][1]}  # from {comm}\n")
                else:
                    # Conflict detected: write all versions
                    for comm, val in values:
                        out.write(f"{oid} = {val}  # from {comm}\n")

        tmpfile.rename(outfile)
        log(f"[DONE] Dump saved: {outfile}", style="green", quiet=quiet)

    except KeyboardInterrupt:
        log(f"[INTERRUPT] Removing partial file: {tmpfile}", style="red", quiet=quiet)
        if tmpfile.exists():
            tmpfile.unlink()
        raise

def main():
    args = parse_args()
    os.makedirs(args.output, exist_ok=True)

    xml_files = find_xml_files(args.input)
    log(f"[+] Found {len(xml_files)} XML file(s)", style="cyan", quiet=args.quiet)

    snmp_hosts = extract_snmp_hosts(xml_files)
    log(f"[+] Found {len(snmp_hosts)} hosts with SNMP and valid creds", style="cyan", quiet=args.quiet)
    with open(Path(args.output) / "snmp_hosts_and_creds.json", "w") as f:
        f.write(snmp_hosts.__repr__())
    if args.quiet:
        for host, creds in snmp_hosts.items():
            run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=True)
    else:
        with Progress(SpinnerColumn(), TextColumn("[cyan]{task.description}"), BarColumn(), TextColumn("{task.completed}/{task.total}"), console=console) as progress:
            task = progress.add_task("[white]Processing hosts...", total=len(snmp_hosts))
            for host, creds in snmp_hosts.items():
                run_snmpbulkwalk(host, creds, args.output, args.prefix, quiet=False)
                progress.advance(task)

if __name__ == "__main__":
    main()
