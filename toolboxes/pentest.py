import os
import sys
import json
import argparse
import shutil

from datetime import datetime
from pathlib import Path
from rich.prompt import Confirm, Prompt
from pentesting.utils import is_in_tmux, md5_hash, get_internal_ip, get_external_ip
from pentesting.utils.logging import ConvenientLogging


class Pentest:
    def __init__(self, args):
        self.args = args
        self.project_path = self._resolve_project_path()
        self.project_json = self.project_path / f".{self.project_path.name}.json"
        self.convenient_logging = ConvenientLogging(self.project_path)
        self.logger = self.convenient_logging.getLogger(name="pentest_phase0_setup")
        self.project_data = {}

    # ------------------------
    # Initialization Helpers
    # ------------------------
    def _resolve_project_path(self):
        if self.args.project:
            return Path(self.args.project).resolve()
        elif self.args.here:
            return Path.cwd()
        else:
            return Path.cwd() / f"pentest_{datetime.now().strftime('%Y-%m-%d')}"

    def _ensure_directories(self):
        self.project_path.mkdir(parents=True, exist_ok=True)
        (self.project_path / "logs").mkdir(exist_ok=True)

    def _check_tmux(self):
        if not self.args.bypass_tmux and not is_in_tmux():
            self.logger.error("[bold red]This script should be run inside tmux. Use --bypass-tmux to skip this check.")
            sys.exit(1)

    def _phase_done(self, phase):
        (self.project_path / f".phase_{phase}").touch()
        self.logger.info(f"Phase {phase} marked as complete.")


    def handle_target(self, target_arg, targets_file):
        if Path(target_arg).exists():
            new_targets = Path(target_arg).read_text().splitlines()
        else:
            new_targets = [target_arg]

        if targets_file.exists():
            existing_targets = targets_file.read_text().splitlines()
            if set(new_targets) != set(existing_targets):
                action = Prompt.ask(
                    "Targets differ. Choose action",
                    choices=["Overwrite", "Merge", "Skip", "Abort"],
                    default="Abort"
                )
                if action == "Overwrite":
                    targets_file.write_text("\n".join(new_targets))
                    (self.project_path / ".new_targets").touch()
                    self.logger.info("Targets overwritten.")
                elif action == "Merge":
                    merged = sorted(set(existing_targets + new_targets))
                    targets_file.write_text("\n".join(merged))
                    (self.project_path / ".new_targets").touch()
                    self.logger.info("Targets merged.")
                elif action == "Skip":
                    self.logger.info("Target update skipped.")
                    return
                else:
                    self.logger.error("Aborting due to target mismatch.")
                    sys.exit(1)
        else:
            targets_file.write_text("\n".join(new_targets))
            self.logger.info("New targets file created.")

    # ------------------------
    # Project Logic
    # ------------------------
    def initialize_new_project(self):
        self.logger.info(f"Initializing new pentest project at {self.project_path}")
        (self.project_path / "scope").mkdir(exist_ok=True)
        (self.project_path / "recon").mkdir(exist_ok=True)

        internal_ip = get_internal_ip()
        external_ip = get_external_ip()
        self.logger.info(f"[yellow]Detected Internal IP:[/] {internal_ip}")
        self.logger.info(f"[yellow]Detected External IP:[/] {external_ip}")

        if not Confirm.ask("Are these IP addresses correct?"):
            self.logger.error("IP addresses not confirmed.")
            sys.exit(-1)

        self.project_data = {"internal_ip": internal_ip, "external_ip": external_ip}
        self._setup_targets()
        self._save_project_data()

    def _setup_targets(self):
        scope_dir = self.project_path / "scope"
        targets_file = scope_dir / "targets.txt"

        if self.args.target:
            self.handle_target(self.args.target, targets_file)
        else:
            existing_target = Path.cwd() / "targets.txt"
            if existing_target.exists():
                if Confirm.ask(f"Use {existing_target} as targets.txt?"):
                    shutil.copy(existing_target, targets_file)
                    self.logger.info("Existing targets.txt copied to scope folder.")
                else:
                    self.logger.error("No target specified, exiting.")
                    sys.exit(-1)
            else:
                self.logger.error("No target specified and no targets.txt found.")
                sys.exit(-1)

        self.project_data["targets_md5"] = md5_hash(targets_file)

    def _save_project_data(self):
        with open(self.project_json, "w") as f:
            json.dump(self.project_data, f, indent=4)

    def load_existing_project(self):
        self.logger.info("Existing project detected. Loading configuration.")
        with open(self.project_json, "r") as f:
            self.project_data = json.load(f)

        self._verify_ip_addresses()
        self._verify_targets()
        self._save_project_data()

    def _verify_ip_addresses(self):
        if self.args.skip_ip_check:
            return

        current_internal = get_internal_ip()
        current_external = get_external_ip()
        if current_internal != self.project_data["internal_ip"] or current_external != self.project_data["external_ip"]:
            self.logger.info(f"[red]IP address mismatch detected.[/]")
            if Confirm.ask("Update IP addresses?"):
                self.project_data["internal_ip"] = current_internal
                self.project_data["external_ip"] = current_external
                self.logger.info("IP addresses updated.")
            else:
                self.logger.error("IP mismatch not confirmed. Exiting.")
                sys.exit(-1)

    def _verify_targets(self):
        targets_file = self.project_path / "scope" / "targets.txt"
        current_hash = md5_hash(targets_file)
        if current_hash != self.project_data["targets_md5"]:
            self.logger.info("[red]Targets have changed![/]")
            if Confirm.ask("Confirm new targets?"):
                self.project_data["targets_md5"] = current_hash
                (self.project_path / ".new_targets").touch()
                self.logger.info("New targets confirmed and flagged for re-run.")
            else:
                self.logger.error("Target change not confirmed. Exiting.")
                sys.exit(-1)

    def run(self):
        self._ensure_directories()
        self._check_tmux()
        if not self.project_json.exists():
            self.initialize_new_project()
        else:
            self.load_existing_project()


# ------------------------
# CLI Entrypoint
# ------------------------
def parse_args():
    parser = argparse.ArgumentParser(description="Pentest Automation Script")
    parser.add_argument("--bypass-tmux", action="store_true", help="Bypass tmux check")
    parser.add_argument("--project", type=str, help="Path to project folder")
    parser.add_argument("--here", action="store_true", help="Use current directory as project folder")
    parser.add_argument("--target", type=str, help="Path/IP/domain for target(s)")
    parser.add_argument("--force-phase", action="store_true", help="Force rerun of phases")
    parser.add_argument("--skip-ip-check", action="store_true", help="Skip IP verification")
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    Pentest(args).run()
